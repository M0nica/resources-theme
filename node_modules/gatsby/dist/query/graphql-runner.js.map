{"version":3,"sources":["../../src/query/graphql-runner.ts"],"names":["GraphQLRunner","constructor","store","schema","schemaCustomization","getState","nodeModel","LocalNodeModel","nodeStore","schemaComposer","composer","createPageDependency","parseCache","Map","validDocuments","WeakSet","scheduleClearCache","clearCache","bind","clear","parse","query","has","set","get","validate","document","errors","length","add","context","result","rootValue","contextValue","customContext","variableValues","Promise","resolve","module","exports"],"mappings":"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","sourcesContent":["import {\n  parse,\n  validate,\n  execute,\n  DocumentNode,\n  GraphQLSchema,\n  Source,\n  GraphQLError,\n  ExecutionResult,\n} from \"graphql\"\nimport { debounce } from \"lodash\"\nimport nodeStore from \"../db/nodes\"\nimport { createPageDependency } from \"../redux/actions/add-page-dependency\"\n\nimport withResolverContext from \"../schema/context\"\nimport { LocalNodeModel } from \"../schema/node-model\"\nimport { Store } from \"redux\"\nimport { IReduxState } from \"../redux/types\"\n\ntype Query = string | Source\n\nclass GraphQLRunner {\n  parseCache: Map<Query, DocumentNode>\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  nodeModel: any // TODO: convert \"../schema/node-model\" from Flow\n\n  schema: GraphQLSchema\n\n  validDocuments: WeakSet<DocumentNode>\n  scheduleClearCache: () => void\n\n  constructor(protected store: Store<IReduxState>) {\n    const { schema, schemaCustomization } = this.store.getState()\n\n    this.nodeModel = new LocalNodeModel({\n      nodeStore,\n      schema,\n      schemaComposer: schemaCustomization.composer,\n      createPageDependency,\n    })\n    this.schema = schema\n    this.parseCache = new Map()\n    this.validDocuments = new WeakSet()\n    this.scheduleClearCache = debounce(this.clearCache.bind(this), 5000)\n  }\n\n  clearCache(): void {\n    this.parseCache.clear()\n    this.validDocuments = new WeakSet()\n  }\n\n  parse(query: Query): DocumentNode {\n    if (!this.parseCache.has(query)) {\n      this.parseCache.set(query, parse(query))\n    }\n    return this.parseCache.get(query) as DocumentNode\n  }\n\n  validate(\n    schema: GraphQLSchema,\n    document: DocumentNode\n  ): readonly GraphQLError[] {\n    if (!this.validDocuments.has(document)) {\n      const errors = validate(schema, document)\n      if (!errors.length) {\n        this.validDocuments.add(document)\n      }\n      return errors\n    }\n    return []\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  query(query: Query, context: Record<string, any>): Promise<ExecutionResult> {\n    const { schema, schemaCustomization } = this.store.getState()\n\n    if (this.schema !== schema) {\n      this.schema = schema\n      this.clearCache()\n    }\n\n    const document = this.parse(query)\n    const errors = this.validate(schema, document)\n\n    const result =\n      errors.length > 0\n        ? { errors }\n        : execute({\n            schema,\n            document,\n            rootValue: context,\n            contextValue: withResolverContext({\n              schema,\n              schemaComposer: schemaCustomization.composer,\n              context,\n              customContext: schemaCustomization.context,\n              nodeModel: this.nodeModel,\n            }),\n            variableValues: context,\n          })\n\n    // Queries are usually executed in batch. But after the batch is finished\n    // cache just wastes memory without much benefits.\n    // TODO: consider a better strategy for cache purging/invalidation\n    this.scheduleClearCache()\n    return Promise.resolve(result)\n  }\n}\n\nmodule.exports = GraphQLRunner\n"],"file":"graphql-runner.js"}